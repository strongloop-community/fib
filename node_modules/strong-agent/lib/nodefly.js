if (global.nodefly) return global.nodefly;

var config = global.nodeflyConfig = require('./config');

var fs      = require('fs');
var util    = require('util');
var path    = require('path');
var events  = require('events');
var os      = require('os');

var proxy   = require('./proxy');
var sender  = require('./sender');
var samples = require('./samples');
var counts  = require('./counts');
var info    = require('./info');
var metrics = require('./metrics');
var transport = require('./transport/uhura');
var loop    = require('./loop');

// Profilers
var cpuProf = require('./profilers/cpu');
var memProf = require('./profilers/memory');

var timekit;
if (os.platform() === 'win32') {
	console.warn('[NodeFly] Timekit does not output correct time on Windows -- It will not be used');
} else {
	try {
		timekit = require('timekit');
	} catch (exp) {
		console.warn('[NodeFly] Timekit Module is Not Installed');
	}
}

var tiers = require('./tiers');

var package = require('../package.json');

/**
 * Cascading config loader
 *
 * Search order:
 *   arguments
 *   process.env
 *   ./nodefly.json
 *   ./package,json
 *   ~/nodefly.json
 *
 * @param   {string} [key]      [API Key]
 * @param   {string} [appName]  [Name to identify app with in dashboard]
 * @returns {object || boolean} [Returns config data, or false if none found]
 */

function ensureConfig (key, appName) {
	var home = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE
		, cwd = process.cwd()
		, env = process.env
		, nfjson
		, pkgjson;

	// Load configs from nodefly.json and package.json
	try { nfjson = require(cwd + '/nodefly.json'); } catch (e) { nfjson = {}; }
	try { pkgjson = require(cwd + '/package.json'); } catch (e) { pkgjson = {}; }
	try { userjson = require(home + '/nodefly.json'); } catch (e) { userjson = {}; }

	var config = {
		key: key || env.NODEFLY_KEY || nfjson.key || pkgjson.nodeflyKey || userjson.key
		, appName: appName || env.NODEFLY_APP_NAME || nfjson.appName || pkgjson.name || userjson.appName
	};

	// Only return config object if we found valid properties.
	if (config.key && config.appName) {
		return config;
	}
	
	return false;
}

var Nodefly = function()
{
	this.sessionId = null;
	this.debug = true;
	var self = this;
	this.cpuinfo = require('./cpuinfo');

	events.EventEmitter.call(this);
};

util.inherits(Nodefly, events.EventEmitter);

exports = module.exports = global.nodefly = new Nodefly();

Nodefly.prototype.profile = function (key, appName, options) {
	var self = this;

	if (typeof options === 'undefined') {
		options = {};
	}

	var config = ensureConfig(key, appName);
	if ( ! config) {
		console.warn('NodeFly configs not defined');
		return;
	}
	
	this.key = config.key;
	
	if (config.appName instanceof Array) {
		this.appName  = config.appName.shift();
		this.hostname = config.appName.join(':');
	} else {
		this.appName  = config.appName;
		this.hostname = os.hostname();
	}


	this.initialized = true;

	proxy.init();
	sender.init();
	samples.init();
	counts.init();
	info.init();
	metrics.init();
	tiers.init();
	loop.init();


	if (timekit) {
		this.timekit = timekit;
		this.timekit_time    = !!timekit.time();
		this.timekit_cputime = !!timekit.cputime();
	}

	this.transport = transport.init({
		agent: this,
		agentVersion: package.version
	});

	this.prepareProbes();
	this.prepareProfilers();
};

Nodefly.prototype.prepareProbes = function () {
	var probes = {};
	var files = fs.readdirSync(path.dirname(require.resolve('./nodefly')) + '/probes');

	files.forEach(function (file) {
		var m = file.match(/^(.*)+\.js$/);
		if (m && m.length == 2) probes[m[1]] = true;
	});

	// init probes
	proxy.after(module.__proto__, 'require', function (obj, args, ret) {
		if (ret.__required__) return;
		if (probes[args[0]] === true) {
			ret.__required__ = true;
			require('./probes/' + args[0])(ret);
		}
	});
};

Nodefly.prototype.prepareProfilers = function () {
	var self = this;

	// // Allow instance profiling events to be triggered from server
	this.transport.on('memory:start', function (rowid) {
		console.log('starting memory profiler', rowid);
		memProf.start();
		
		self.transport.once('memory:stop', function (rowid) {
			console.log('stopping memory profiler', rowid);
			memProf.stop();
		});
	});

	// Allow cpu profiling events to be triggered from server
	this.transport.on('cpu:start', function (rowid) {
		console.log('starting cpu profiler', rowid);
		cpuProf.start();

		self.transport.once('cpu:stop', function () {
			console.log('stopping cpu profiler', rowid);
			cpuProf.stop(function (data) {
				console.log('sending cpu profiler result', rowid);
				self.transport.send('profileRun', rowid, data);
			});
		});
	});
};

Nodefly.prototype.time = function (label, context) {
  if(this.paused || !this.initialized) return;

  this.times[label] = {
    time: samples.time("Custom", label, true),
    stackTrace: samples.stackTrace(),
    context: context
  };
};


Nodefly.prototype.timeEnd = function (label, context) {
  if(this.paused || !this.initialized) return;

  var time = this.times[label];
  delete this.times[label];
  if(!time) throw new Error('No such label: ' + label);

  if(!time.time.done()) return;

  var obj = {'Type': 'Custom'};

  // merge start context
  if(time.context) {
    for(var prop in time.context) {
      obj[prop] = time.context[prop];
    }
  }

  // merge end context
  if(context) {
    for(var prop in context) {
      obj[prop] = context[prop];
    }
  }

  // add stack trace
  obj['Stack trace'] = time.stackTrace;

  samples.add(time.time, obj, 'Custom: ' + label);
};


Nodefly.prototype.metric = function (scope, name, value, unit, op, persist) {
  if(!this.initialized) return;
  metrics.add(scope, name, value, unit, op, persist);
};


Nodefly.prototype.hrtime = function () {
  if(this.timekit_time) {
    return this.timekit.time();
  }
  else if(this.hasHrtime) {
    var ht = process.hrtime();
    return ht[0] * 1000000 + Math.round(ht[1] / 1000);
  }
  else {
    return new Date().getTime() * 1000;
  }
};


Nodefly.prototype.micros = function () {
  return this.timekit_time ? this.timekit.time() : new Date().getTime() * 1000;
};


Nodefly.prototype.millis = function () {
  return this.timekit_time ? this.timekit.time() / 1000 : new Date().getTime();
};


Nodefly.prototype.cputime = function () {
  return this.timekit_cputime ? this.timekit.cputime() : undefined;
};


Nodefly.prototype.log = function (msg) {
  if (this.debug && msg) console.log('nodefly:', msg);
};


Nodefly.prototype.error = function (e) {
  if (this.debug && e) console.error('nodefly error:', e, e.stack);
};


Nodefly.prototype.dump = function (obj) {
  if (this.debug) console.log(util.inspect(obj, false, 10, true));
};


Nodefly.prototype.message = function (msg) {
  util.log("\033[1;31mNodefly:\033[0m " + msg);
};
